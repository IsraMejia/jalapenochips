Ahora aprende la logica que se lleva acabo en este programa para realizar las interrupciones 
donde cuando se presiona un boton para realiar una tarea se pasa a la nueva tarea interrumpiendo esa, pero el menor tiempo posible,
e inmediatamente despues continua donde sequedo para continuar con el rango de tiempo destinado a la tarea orignal.

De igual forma agrega la logica para el control del ventilador y el atomizador al codigo que hemos generado anteriormente.

Ejemplo de codigo de imterrupciones con controlador de ventilador y atomizador :
#include <Servo.h>

const int motorPin = 9;
const int ledPin = 13;
const int enceder_ventilador = 2;
const int enceder_atomizador = 4;
const int servoPin = 10;

Servo myServo;

void setup() {
  pinMode(motorPin, OUTPUT);
  pinMode(ledPin, OUTPUT);
  pinMode(enceder_ventilador, INPUT_PULLUP); // Usa la resistencia pull-up interna
  pinMode(enceder_atomizador, INPUT_PULLUP); // Usa la resistencia pull-up interna
  myServo.attach(servoPin);

  // Inicializa el servo en una posición neutra
  myServo.write(90);
}

void loop() { 
  if(digitalRead(enceder_atomizador) == LOW){
    atomizar_agua();
  }

  // Verificar si el botón está presionado
  if (digitalRead(enceder_ventilador) == LOW) { // El botón está presionado cuando el pin está LOW
    encender_ventilador();     // Apaga el LED
  }
}

void encender_ventilador(){
  digitalWrite(ledPin, HIGH);        // Enciende el LED
    
    int elapsedTime = 0;
    do {
      digitalWrite(motorPin, HIGH);    // Enciende el motor
      delay(500);                     // Mantén el motor encendido por 1 segundo
      digitalWrite(motorPin, LOW);     // Apaga el motor
      elapsedTime += 1;                // Incrementa el tiempo transcurrido en 1 segundo
      if(digitalRead(enceder_atomizador) == LOW){
        atomizar_agua();
      }      
      // Aquí podrías añadir un delay si quieres esperar un tiempo específico antes de volver a encender el motor.
      // delay(500); // Espera 500 ms (medio segundo) antes de volver a encender el motor, por ejemplo.
    } while (elapsedTime < 30);        // Repite hasta que se acumulen 15 segundos de motor encendido

  digitalWrite(ledPin, LOW);         // Apaga el LED

}

void atomizar_agua(){
  digitalWrite(ledPin, HIGH);        // Enciende el LED
  myServo.write(190);                  // Mueve el servo a la posición 0 grados
  delay(800);                         // Mantén el servo en esta posición por 1 segundo
  myServo.write(90);                 // Regresa el servo a la posición 90 grados (neutral)
  digitalWrite(ledPin, LOW);         // Apaga el LED
  
}


Codigo al que se tiene que adaptar el modo de interrupciones y agregar la logica del ventilador , asi como del atomizador:
Voy a detallar el flujo de control del código y agregar comentarios línea por línea para que sea más fácil de entender.

### Flujo de Control

1. **Configuración Inicial:**
   - Se inicializan las librerías, las variables y los pines de entrada y salida.
   - Se configura el LCD y se muestran los mensajes iniciales.

2. **Loop Principal:**
   - Se verifica si se presionan los botones para encender/apagar el ventilador, atomizar agua, servir agua o detener el servicio de agua.
   - Cada acción correspondiente se ejecuta según el botón presionado.
   - Se controla la duración y el brillo del LED de agua mientras se sirve agua.

### Código con Comentarios

```cpp
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// Dirección I2C del módulo, generalmente es 0x27 o 0x3F
LiquidCrystal_I2C lcd(0x27, 16, 2);

// Definir pines para los botones y los LEDs
const int buttonPinOn = 2;          // Pin para el botón de encendido del ventilador
const int buttonPinOff = 3;         // Pin para el botón de apagado del ventilador
const int buttonPinAtomizar = 4;    // Pin para el botón de atomizar agua
const int buttonPinServir = 5;      // Pin para el botón de servir agua
const int buttonPinStopAgua = 6;    // Pin para el botón de detener el servicio de agua
const int ledPin = 9;               // Pin PWM para el LED del ventilador
const int ledAtomizarPin = 10;      // Pin para el LED de atomizar agua
const int ledAguaPin = 11;          // Pin PWM para el LED de servir agua

// Variables de control
bool ventiladorEncendido = false;   // Estado del ventilador
int velocidad = 0;                  // Contador para la velocidad del ventilador
bool sirviendoAgua = false;         // Estado del servicio de agua
unsigned long tiempoInicioServir = 0; // Tiempo de inicio del servicio de agua

void setup() {
  Wire.begin(); // Inicia la comunicación I2C

  // Inicializar el LCD con 16 columnas y 2 filas
  lcd.begin(16, 2);
  lcd.backlight(); // Encender la luz de fondo del LCD

  // Configurar los pines de los botones como entradas con resistencia pull-up interna
  pinMode(buttonPinOn, INPUT_PULLUP);
  pinMode(buttonPinOff, INPUT_PULLUP);
  pinMode(buttonPinAtomizar, INPUT_PULLUP);
  pinMode(buttonPinServir, INPUT_PULLUP);
  pinMode(buttonPinStopAgua, INPUT_PULLUP);

  // Configurar los pines de los LEDs como salidas
  pinMode(ledPin, OUTPUT);
  pinMode(ledAtomizarPin, OUTPUT);
  pinMode(ledAguaPin, OUTPUT);

  // Mostrar el estado inicial del ventilador en el LCD
  actualizarPantalla();
}

void loop() {
  // Verificar si el botón de encendido del ventilador está presionado
  if (digitalRead(buttonPinOn) == LOW) {
    delay(200); // Debounce para evitar múltiples lecturas
    if (digitalRead(buttonPinOn) == LOW) {
      if (!ventiladorEncendido) {
        // Encender el ventilador por primera vez
        ventiladorEncendido = true;
        velocidad = 1; // Empezar con velocidad 1
      } else {
        // Incrementar la velocidad del ventilador
        if (velocidad < 3) {
          velocidad++;
        }
      }
      // Actualizar el estado del LED del ventilador
      actualizarLed();
      // Actualizar el mensaje en la pantalla LCD
      actualizarPantalla();
      // Esperar a que se suelte el botón
      while (digitalRead(buttonPinOn) == LOW);
    }
  }

  // Verificar si el botón de apagado del ventilador está presionado
  if (digitalRead(buttonPinOff) == LOW) {
    delay(200); // Debounce para evitar múltiples lecturas
    if (digitalRead(buttonPinOff) == LOW) {
      // Apagar el ventilador
      ventiladorEncendido = false;
      velocidad = 0; // Reiniciar la velocidad
      // Actualizar el estado del LED del ventilador
      actualizarLed();
      // Actualizar el mensaje en la pantalla LCD
      actualizarPantalla();
      // Esperar a que se suelte el botón
      while (digitalRead(buttonPinOff) == LOW);
    }
  }

  // Verificar si el botón de atomizar agua está presionado
  if (digitalRead(buttonPinAtomizar) == LOW) {
    delay(200); // Debounce para evitar múltiples lecturas
    if (digitalRead(buttonPinAtomizar) == LOW) {
      // Mostrar mensaje de atomización y encender LED de atomizar
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("atomizar awa");
      digitalWrite(ledAtomizarPin, HIGH);
      delay(1000); // Mantener el mensaje y el LED encendido por 1 segundo
      digitalWrite(ledAtomizarPin, LOW);
      // Volver a mostrar el estado del ventilador
      actualizarPantalla();
      // Esperar a que se suelte el botón
      while (digitalRead(buttonPinAtomizar) == LOW);
    }
  }

  // Verificar si el botón de servir agua está presionado
  if (digitalRead(buttonPinServir) == LOW) {
    delay(200); // Debounce para evitar múltiples lecturas
    if (digitalRead(buttonPinServir) == LOW) {
      // Mostrar mensaje de servir agua y encender LED de agua
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("sirviendo 100ml");
      sirviendoAgua = true;
      tiempoInicioServir = millis(); // Registrar el tiempo de inicio del servicio de agua
      // Esperar a que se suelte el botón
      while (digitalRead(buttonPinServir) == LOW);
    }
  }

  // Verificar si el botón de detener el servicio de agua está presionado
  if (digitalRead(buttonPinStopAgua) == LOW) {
    delay(200); // Debounce para evitar múltiples lecturas
    if (digitalRead(buttonPinStopAgua) == LOW) {
      // Si está sirviendo agua, detener el proceso
      if (sirviendoAgua) {
        lcd.clear();
        lcd.setCursor(0, 0);
        lcd.print("stop agua");
        digitalWrite(ledAguaPin, LOW);
        delay(1000); // Mostrar el mensaje por 1 segundo
        sirviendoAgua = false;
        actualizarPantalla(); // Volver a mostrar el estado del ventilador
      }
      // Esperar a que se suelte el botón
      while (digitalRead(buttonPinStopAgua) == LOW);
    }
  }

  // Controlar la duración del servicio de agua
  if (sirviendoAgua) {
    unsigned long tiempoActual = millis();
    unsigned long tiempoTranscurrido = tiempoActual - tiempoInicioServir;
    if (tiempoTranscurrido >= 5000) {
      // Detener el servicio de agua después de 5 segundos
      digitalWrite(ledAguaPin, LOW);
      sirviendoAgua = false;
      actualizarPantalla();
    } else {
      // Ajustar la luminosidad del LED de agua en función del tiempo transcurrido
      int brillo = map(tiempoTranscurrido, 0, 4000, 85, 255); // Mapear el tiempo a brillo
      analogWrite(ledAguaPin, brillo);
    }
  }
}

// Función para actualizar la pantalla LCD
void actualizarPantalla() {
  lcd.clear(); // Limpiar la pantalla LCD
  lcd.setCursor(0, 0); // Posicionar el cursor en la primera columna, primera fila
  if (ventiladorEncendido) {
    lcd.print("Ventilador On"); // Imprimir estado del ventilador en la primera fila
    lcd.setCursor(0, 1); // Posicionar el cursor en la primera columna, segunda fila
    lcd.print("v= "); // Imprimir "v= " en la segunda fila
    lcd.print(velocidad); // Imprimir la velocidad actual en la segunda fila
  } else {
    lcd.print("Ventilador"); // Imprimir "Ventilador" en la primera fila
    lcd.setCursor(0, 1); // Posicionar el cursor en la primera columna, segunda fila
    lcd.print("apagado"); // Imprimir "apagado" en la segunda fila
  }
}

// Función para actualizar el brillo del LED del ventilador
void actualizarLed() {
  if (ventiladorEncendido) {
    // Ajustar el brillo del LED en función de la velocidad del ventilador
    int brillo = map(velocidad, 1, 3, 85, 255); // Mapear velocidad 1-3 a brillo 85-255
    analogWrite(ledPin, brillo);
  } else {
    // Apagar el LED si el ventilador está apagado
    analogWrite(ledPin, 0);
  }
}
```

### Descripción detallada del flujo de control:

1. **Configuración Inicial (`setup()`)**
   - Se inicializan las librerías y se configuran los p

ines como entradas o salidas.
   - Se configura y se enciende la pantalla LCD.
   - Se muestra el estado inicial del ventilador en la pantalla.

2. **Loop Principal (`loop()`)**
   - **Botón de Encendido del Ventilador:**
     - Si el botón está presionado, se incrementa la velocidad del ventilador o se enciende si estaba apagado.
     - Se actualiza el LED del ventilador y la pantalla LCD.
   - **Botón de Apagado del Ventilador:**
     - Si el botón está presionado, se apaga el ventilador y se reinicia la velocidad.
     - Se actualiza el LED del ventilador y la pantalla LCD.
   - **Botón de Atomizar Agua:**
     - Si el botón está presionado, se muestra un mensaje de atomización y se enciende el LED de atomización durante un segundo.
     - Luego, se vuelve a mostrar el estado del ventilador en la pantalla LCD.
   - **Botón de Servir Agua:**
     - Si el botón está presionado, se muestra un mensaje de servir agua y se enciende el LED de servir agua.
     - Se inicia un temporizador para controlar la duración del servicio de agua.
   - **Botón de Detener el Servicio de Agua:**
     - Si el botón está presionado y se está sirviendo agua, se detiene el proceso y se muestra un mensaje.
   - **Control de la Duración del Servicio de Agua:**
     - Si se está sirviendo agua, se verifica el tiempo transcurrido. Si han pasado 5 segundos, se detiene el servicio.
     - Durante el servicio, se ajusta la luminosidad del LED de agua según el tiempo transcurrido.

3. **Funciones Auxiliares**
   - `actualizarPantalla()`: Actualiza la pantalla LCD con el estado actual del ventilador.
   - `actualizarLed()`: Ajusta el brillo del LED del ventilador según la velocidad.

Este flujo asegura que el programa responda a los botones de control y actualice el estado de los dispositivos y la pantalla en consecuencia.
Ten en cuenta un reacomodo de los pines que sea ordenado y se pueda usar el minimo de pines que puedan hacer señales pwm 